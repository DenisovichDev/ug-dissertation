import numpy as np
import random
from tqdm import tqdm
from utils.convergence import Convergence
import time

class SimulatedAnnealing:
    def __init__(self, distances, n_iterations, initial_temp, cooling_rate, backend_test=False):
        self.distances = distances
        self.n_iterations = n_iterations
        self.initial_temp = initial_temp
        self.cooling_rate = cooling_rate
        self.backend_test = backend_test
        self.convergence = Convergence()

    def run(self):
        """
            Run the Simulated Annealing algorithm and return the shortest path found.

            :return: Tuple of the shortest path and its distance.
        """
        current_solution = self.random_solution()
        current_distance = self.calculate_distance(current_solution)
        best_solution = current_solution
        best_distance = current_distance

        temperature = self.initial_temp
        time_a = time.time()

        for iteration in tqdm(range(self.n_iterations), desc="cooling hot metal..."):
            new_solution = self.get_neighbor(current_solution)
            new_distance = self.calculate_distance(new_solution)
            delta = new_distance - current_distance
            
            if delta < 0 or random.uniform(0, 1) < np.exp(-delta / temperature):
                current_solution, current_distance = new_solution, new_distance
                if current_distance < best_distance:
                    best_solution, best_distance = current_solution, current_distance

            temperature *= self.cooling_rate
            self.convergence.add_iteration(iteration, best_distance)

        time_b = time.time()

        if self.backend_test:
            self.convergence.plot_convergence()
        best_path = []
        for i in range(len(best_solution)-1):
            best_path.append((best_solution[i], best_solution[i+1]))
        return best_path, best_distance, self.convergence.convergence_data, self.convergence.calculate_convergence_rate(), time_b - time_a

    def random_solution(self):
        """
            Generate a random initial solution.

            :return: A random path.
        """
        solution = list(range(len(self.distances)))
        random.shuffle(solution)
        return solution

    def get_neighbor(self, solution):
        """
            Generate a neighboring solution by swapping two cities.

            :param solution: The current solution (path).
            :return: A new solution (path) generated by swapping two cities.
        """
        new_solution = solution[:]
        idx1, idx2 = random.sample(range(len(solution)), 2)
        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]
        return new_solution

    def calculate_distance(self, solution):
        """
            Calculate the total distance of a given path.

            :param solution: The path.
            :return: The total distance of the path.
        """
        total_distance = 0
        for i in range(len(solution)):
            start = solution[i]
            end = solution[(i + 1) % len(solution)]
            total_distance += self.distances[start, end]
        return total_distance
